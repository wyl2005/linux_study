1. 类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。

私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。
只有类和友元函数可以访问私有成员。

2. 不存在空引用，必须连接到一块合法的内存。
    引用必须在声明时将其初始化，（引用分配内存空间时，必须进行初始化！ ）。
	指针可以在任何时间被初始化
    引用更接近const指针（引用本质上是一个指针常量），必须在创建时进行初始化，
	一旦引用和某个变量关联起来，该引用就会一直指向该变量。。
	不能建立引用数组 
	int a[3]; 
	int &b[3]=a; //错误，不能建立引用数组 C++中没有数组的引用
	int &b=a[0]; //错误，不能作为数组元素的别名
	不能建立引用的引用，不能建立引用的指针
	可以取引用的地址
	
	建立指针的引用：
		int m_value = 1;

		void func(int *&p)
		{
			p = &m_value;

			// 也可以根据你的需求分配内存
			p = new int;
			*p = 5;
		}

		int main(int argc, char *argv[])
		{
			int n = 2;
			int *pn = &n;
			cout << *pn << endl;
			func(pn);
			cout << *pn <<endl;
			return 0;
		}
		output: 2
				5
		看一下func(int *&p)方法
		p:  是指针的引用，main()方法里的 *pn
		*p:是main()方法里的pn指向的内容

	变量名称是变量附属在内存位置中的标签， 可以把引用当成是变量附属在内存位置中的第二个标签
	引用通常用于函数参数列表和函数返回值。

把引用作为参数：
	C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。
	以引用作为参数的函数，可以把变量传入，但不能传入常量。

引用作为返回值：
	当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，
	但是，可以返回一个对静态变量的引用。
	用引用返回一个函数的最大好处是，在内存中不产生被返回值的副本。
	Return by reference is also fast, which can be useful when returning
	structs and classes.


3. 派生类可以访问基类中所有的非私有成员。

一个派生类继承了所有的基类方法，但下列情况除外：

基类的构造函数、析构函数和拷贝构造函数。
基类的重载运算符。
基类的友元函数。

4. 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。
包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。

您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

5. 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。
数据抽象是一种依赖于接口和实现分离的编程（设计）技术。

数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。

如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。
抽象类不能被用于实例化对象，它只能作为接口使用。
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类

6. 之前一些编译器使用 C++11 的编译参数是 -std=c++11
g++ -std=c++11 test.cpp -lpthread

7. vector是一个相同类型的集合,存放相同类型的数据.要使用它的头文件<vector>,并且使用命名空间,using std::vector; 
引出c++类模板和函数模板.这里的vector是一个类模板.

模板本身不是类也不是函数,可以把模板看成是要生成类或者函数的一份说明.编译器根据模板创建类或者函数的过程称为实例化,也就是说需要指定模板需要转化成什么类型?

提供的信息:在模板名字后面加上一对尖括号.来指定需要实例化成什么类.

Vector是一个封装了动态大小数组的顺序容器（sequence Container）。
可以简单的任务，向量是一个能够存放任意类型的动态数组。


8. 模板定义：模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。
模版可以分为两类，一个是函数模版，另外一个是类模版。

9, 所谓的函数模板，实际上是建立一个通用的函数，其函数的类型和形参的类型不具体指定，用一个虚拟的类型来代表，
这个通用的函数就成为函数模板。凡是函数体相同的函数都可以用这个模板来代替，而不必定义多个函数，
只需在模板中定义一次就行了，在调用函数的时候系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。

相对于函数重载而言，模板具有得天独厚的优势，它不需要重复定义，所以使用起来比函数重载更简洁，
但应注意的一点，函数模板只适用于函数的参数个数相同而类型不同，且函数体相同的情况，如果参数的个数不同，
则不能用函数模板，这就是函数模板相对于函数重载的缺陷。

当模板和重载冲突的时候 ，就优先调用重载。

10.  在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。
    因此，在成员函数内部，它可以用来指向调用对象。
	this 的目的总是指向“这个”对象，所以 this 是一个常量指针（参见2.4.2节，第56页），我们不允许改变 this 中保存的地址

11. 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。
    与其他函数一样，重载运算符有一个返回类型和一个参数列表。

Box operator+(const Box&);

11. c++ STL （标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。
    容器（Containers）	容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。
	算法（Algorithms）	 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。
	迭代器（iterators）	 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。

12. 多态，虚函数，纯虚函数。
多态：多种形态，当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。
	调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

虚函数：在基类中使用关键字virtual声明的函数，在派生类中重新定义基类中定义的虚函数时，
		会告诉编译器不要静态链接到该函数。
		我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作
		称为动态链接。

纯虚函数：virtual int funtion1() =0;
		=0 告诉编译器，函数没有主体。
		纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义
		实例，但可以声明指向实现该抽象类的具体类的指针或引用。

模板：使用模板的目的是能够让程序员编写与类型无关的代码。
	对函数模板而言不存在h(int, int)这样的调用，不能在函数调用的参数中指定模板形参的类型，
	对函数模板的调用应使用实参推演来进行：h(2,3)或者int a, b; h(a,b)

	类模板形参不存在实参推演的问题。

重载：
c++允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。
重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同的名称的声明，
但他们的参数列表定义不同。

当调用一个重载函数或重载运算符时，编译器通过把你所使用的参数类型与定义中的参数类型进行比较，
决定选用最合适的定义，称为重载决策。

类的重载、覆盖、重定义：
重载要求参数列表必须不同，比如参数的类型不同、参数的个数不同、参数的顺序不同。
	如果仅仅是函数的返回值不同是没办法重载的，因为重载要求参数列表必须不同。
	（发生在同一个类里）
覆盖（多态）是存在类中，子类重写从基类继承过来的函数。被重写的函数必须是virtual的。
	但是函数名、返回值、参数列表都必须和基类相同。
	（发生在基类和子类）
重定义（隐藏）：子类重新定义父类中有相同名称的非虚函数（参数列表可以不同）。
	（发送在基类和子类）
12. 
delete ptr -- 用来释放内存，且只用来释放ptr 指向的内存。
delete[] rg -- 释放rg指向的内存，还逐一调用数组中每个对象的destructor
               对于象int/char/int */struct 等简单的数据类型，由于对象没有destructor,
			   所以用delete 和delete[] 是一样的，但是如果是C++对象数组就不同了！！

13. new 与 malloc相比，主要优点是，new不只分配了内存，还创建了对象。
new 的功能是在堆区新建一个对象，并返回该对象的指针。
新建对象的意思是，将调用该类的构造函数。

而malloc只是机械的分配一块内存，如果用malloc在堆区创建一个对象的话，是不会调用构造函数的。
同样的，用 delete 去释放一个堆区的对象，会调用该对象的析构函数。
用 free 去释放一个堆区的对象，不会调用该对象的析构函数。

new 是c++中的运算符(其地位等同于“+”,“=”)。
new 和 delete 是配对使用的。
new 可以看做是malloc 加构造函数的执行,就是new更高级一些｡

14. 
声明(declaration) 指定了一个变量的标识符，用来描述变量的类型（是类型、对象、或者函数等），
	声明用于编译器（compiler）识别变量名所引用的实体。
	声明是为了让编译器正确处理对声明变量和函数的引用。
	extern int bar;
	extern int func(int, int)
	double f(int, double) //对于函数声明，externality关键字可以省略
	class foo;
	
定义（definition）是对声明的实现（实例化），连接器（linker）需要定义来引用内存实体。
	定义是给一个变量分配内存的过程，或者说明一个函数具体干什么用。
	int bar;
	int func(int h, int w) { return h*w;}
	double f(int i,double d) {return i+d;}
	class foo {}; //foo 这里已经用于自己的内存了。

定义操作只能做一次，如果忘记定义一些你已经声明过的变量，linker是不知道这些引用该连接到
哪块内存上的，会包missing symbols的错误。
如果定义变量超过一次，linker是不知道把引用和哪块内存连接，会报duplicated symbols错误。
以上的symbols其实就是指定义后的变量名，也就是其标识的内存块。

15. 拷贝构造函数：在创建对象时，使用同一类之前创建的对象来初始化新创建的对象。
如果在类中没有定义拷贝构造函数，编译器会自行定义一个。
如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。
	通常用于：
		一个对象以值传递的方式传入函数体
		一个对象以值传递的方式从函数返回
		一个对象需要通过另外一个对象进行初始化
c++支持两种初始化形式：
A x(2); 	//直接初始化，调用构造函数
A y = x;	//拷贝初始化，调用拷贝构造函数

15. C++11提供了对匿名函数的支持，称为lambda表达式。
Lambda表达式把函数看做对象。lambda表达式可以像对象一样使用，比如可以将它们复制给变量、
作为参数传递、还可以像函数一样对其求值。
Lambda表达式具体形式如下：
[capture](parameters)->return-type{body}

每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类重载了()函数调用运算符）
我们称为闭包类（closure type）。在运行时，lambda表达式会返回一个匿名的闭包实例，
它是一个右值。闭包的一个强大之处是其可以通过传值或引用的方式捕获其封装作用域内的变量。

16. 闭包 closure
	闭包是带有上下文的函数，说白了，就是有状态的函数。意思是这个闭包有属于自己的变量，
	这些变量的值是创建闭包的时候设置的，并在调用闭包的时候，可以访问这些变量。
	
	函数是代码、状态是一组变量，将代码和一组变量捆绑（bind），就形成了闭包。
	闭包的状态捆绑，必须发生在运行时。
	
	C++里使用闭包的3个办法：
		重载operator()
		lambda
		boost::bind / std::bind

17. 模板 template，是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。
	模板是创建泛型类或函数的蓝图或公式。库容器，比如向量、迭代器和算法，都是泛型编程的例子。
		他们都使用了模板的概念。比如：vector<int> 或 vector<float>

18. C++11 中引入的auto主要有两种用途：自动类型推断和返回值占位。
	auto自动类型推断，用于从初始化表达式中推断出变量的数据类型。

19. 静态成员变量在类中仅仅是声明，没有定义，所以要在类的外面定义，实际上是给静态成员
变量分配内存。如果不加定义会报错，初始化是赋一个初始值，而定义是分配内存。


