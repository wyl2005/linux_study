1. 类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。

私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。

2. 不存在空引用，必须连接到一块合法的内存。
    引用必须在声明时将其初始化，（引用分配内存空间时，必须进行初始化！ ）。指针可以在任何时间被初始化
    引用更接近const指针（引用本质上是一个指针常量），必须在创建时进行初始化，一旦引用和某个变量关联起来，该引用就会一直指向该变量。。
	不能建立引用数组 
	int a[3]; 
	int &b[3]=a; //错误，不能建立引用数组 C++中没有数组的引用
	int &b=a[0]; //错误，不能作为数组元素的别名
	不能建立引用的引用，不能建立引用的指针
	可以取引用的地址
	
	建立指针的引用：
		int m_value = 1;

		void func(int *&p)
		{
			p = &m_value;

			// 也可以根据你的需求分配内存
			p = new int;
			*p = 5;
		}

		int main(int argc, char *argv[])
		{
			int n = 2;
			int *pn = &n;
			cout << *pn << endl;
			func(pn);
			cout << *pn <<endl;
			return 0;
		}
		output: 2
				5
		看一下func(int *&p)方法
		p:  是指针的引用，main()方法里的 *pn
		*p:是main()方法里的pn指向的内容

	变量名称是变量附属在内存位置中的标签， 可以把引用当成是变量附属在内存位置中的第二个标签
	引用通常用于函数参数列表和函数返回值。

把引用作为参数：
	C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。
	以引用作为参数的函数，可以把变量传入，但不能传入常量。

引用作为返回值：
	当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，
	但是，可以返回一个对静态变量的引用。
	用引用返回一个函数的最大好处是，在内存中不产生被返回值的副本。
	Return by reference is also fast, which can be useful when returning structs and classes.


3. 派生类可以访问基类中所有的非私有成员。

一个派生类继承了所有的基类方法，但下列情况除外：

基类的构造函数、析构函数和拷贝构造函数。
基类的重载运算符。
基类的友元函数。

4. 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。
包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。

您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

5. 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。
数据抽象是一种依赖于接口和实现分离的编程（设计）技术。

数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。

如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。
抽象类不能被用于实例化对象，它只能作为接口使用。
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类

6. 之前一些编译器使用 C++11 的编译参数是 -std=c++11
g++ -std=c++11 test.cpp -lpthread

7. vector是一个相同类型的集合,存放相同类型的数据.要使用它的头文件<vector>,并且使用命名空间,using std::vector; 
引出c++类模板和函数模板.这里的vector是一个类模板.

模板本身不是类也不是函数,可以把模板看成是要生成类或者函数的一份说明.编译器根据模板创建类或者函数的过程称为实例化,也就是说需要指定模板需要转化成什么类型?

提供的信息:在模板名字后面加上一对尖括号.来指定需要实例化成什么类.

Vector是一个封装了动态大小数组的顺序容器（sequence Container）。
可以简单的任务，向量是一个能够存放任意类型的动态数组。


8. 模板定义：模板就是实现代码重用机制的一种工具，它可以实现类型参数化，即把类型定义为参数， 从而实现了真正的代码可重用性。
模版可以分为两类，一个是函数模版，另外一个是类模版。

9, 所谓的函数模板，实际上是建立一个通用的函数，其函数的类型和形参的类型不具体指定，用一个虚拟的类型来代表，
这个通用的函数就成为函数模板。凡是函数体相同的函数都可以用这个模板来代替，而不必定义多个函数，
只需在模板中定义一次就行了，在调用函数的时候系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。

相对于函数重载而言，模板具有得天独厚的优势，它不需要重复定义，所以使用起来比函数重载更简洁，
但应注意的一点，函数模板只适用于函数的参数个数相同而类型不同，且函数体相同的情况，如果参数的个数不同，
则不能用函数模板，这就是函数模板相对于函数重载的缺陷。

当模板和重载冲突的时候 ，就优先调用重载。

10.  在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。
this 的目的总是指向“这个”对象，所以 this 是一个常量指针（参见2.4.2节，第56页），我们不允许改变 this 中保存的地址

11. 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

Box operator+(const Box&);

11. c++ STL （标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。
    容器（Containers）	容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。
	算法（Algorithms）	 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。
	迭代器（iterators）	 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。

12. 多态，虚函数，纯虚函数。
模板：使用模板的目的是能够让程序员编写与类型无关的代码。
	对函数模板而言不存在h(int, int)这样的调用，不能在函数调用的参数中指定模板形参的类型，
	对函数模板的调用应使用实参推演来进行：h(2,3)或者int a, b; h(a,b)

	类模板形参不存在实参推演的问题。

c++允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。
重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同的名称的声明，但他们的参数列表定义不同。

当调用一个重载函数或重载运算符时，编译器通过把你所使用的参数类型与定义中的参数类型进行比较，
决定选用最合适的定义，称为重载决策。

12. 
delete ptr -- 用来释放内存，且只用来释放ptr 指向的内存。
delete[] rg -- 释放rg指向的内存，还逐一调用数组中每个对象的destructor
               对于象int/char/int */struct 等简单的数据类型，由于对象没有destructor,
			   所以用delete 和delete[] 是一样的，但是如果是C++对象数组就不同了！！

13. new 与 malloc相比，主要优点是，new不只分配了内存，还创建了对象。
new 的功能是在堆区新建一个对象，并返回该对象的指针。
新建对象的意思是，将调用该类的构造函数。

而malloc只是机械的分配一块内存，如果用malloc在堆区创建一个对象的话，是不会调用构造函数的。
同样的，用 delete 去释放一个堆区的对象，会调用该对象的析构函数。
用 free 去释放一个堆区的对象，不会调用该对象的析构函数。

new 是c++中的运算符(其地位等同于“+”,“=”)。
new 和 delete 是配对使用的。
new 可以看做是malloc 加构造函数的执行,就是new更高级一些｡



