1. r''表示''内部的字符串默认不转义

2. 同一个变量可以反复赋值，而且可以是不同类型的变量。
   这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。
   静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。
   例如Java是静态语言，赋值语句如下（// 表示注释）：
        int a = 123; // a是整数类型变量
        a = "ABC"; // 错误：不能把字符串赋给整型变量
   
   可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的
   
3. 当我们写：

a = 'ABC'
时，Python解释器干了两件事情：

在内存中创建了一个'ABC'的字符串；

在内存中创建了一个名为a的变量，并把它指向'ABC'。

4. /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：
还有一种除法是//，称为地板除，两个整数的除法仍然是整数：

5. 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。
如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes

纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes
>>> '中文'.encode('utf-8')
b'\xe4\xb8\xad\xe6\x96\x87'

如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes
>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
'中文'

6.  list（列表 [] ）是一种有序的集合，可以随时添加和删除其中的元素。

    tuple(元组 () )：另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改
    
    dict {} 的key必须是不可变对象。因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。
    这个通过key计算位置的算法称为哈希算法（Hash）。
    dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。
    >>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
    >>> 'Thomas' in d
    >>> d.get('Thomas')
    >>> d.get('Thomas', -1)
    >>> d.pop('Bob')

    set {} 和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
    要创建一个set，需要提供一个list作为输入集合： s = set([1, 2, 3])
    set可以看成数学意义上的无序和无重复元素的集合
   
7.  dict的key必须是不可变对象。
    str, None 是不变对象，而list是可变对象。
    tuple和list非常类似，但是tuple一旦初始化就不能修改，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。
         即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！
         要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。
    
    由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。
    我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

8. 参数：
>>> from collections import Iterable
    if not isinstance(x, (int, float)):
        raise TypeError('bad operand type')

    位置参数：def power(x, n):

    默认参数：def power(x, n=2): 
        必选参数在前，默认参数在后。默认参数必须指向不变对象！如果是可变对象，程序运行时会有逻辑错误！

    可变参数：def calc(*args): 
        可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
        允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。
    def calc(*numbers):
        sum = 0
        for n in numbers:
            sum = sum + n * n
        return sum

    >>> calc(1, 2)
    >>> calc()


    
    关键字参数：def person(name, age, **kw): 
        关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。
        允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict
        **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，
        注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。
        对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。
    
    命名关键字参数：def person(name, age, *, city, job):
        命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。
        定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。
        *后面的参数被视为命名关键字参数。命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：

9. 如果一个函数在内部调用自身本身，这个函数就是递归函数（recursion）。
   递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
    使用递归函数需要注意防止栈溢出。

    迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。
    每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。

10. L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。

11. 迭代dict的key, 可以用：      for key in d:
    迭代value，可以用:           for value in d.values():
    同时迭代key和value，可以用： for k, v in d.items():
    
12. 
列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。
>>> [x * x for x in range(1, 11) if x % 2 == 0]

通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。
要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>


在Python中，这种一边循环一边计算的机制，称为生成器：generator。
如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：
函数是顺序执行，遇到return语句或者最后一行函数语句就返回。
generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代

>>> import os # 导入os模块，模块的概念后面讲到
>>> [d for d in os.listdir('.')] # os.listdir可以列出文件和目录

13. 我们已经知道，可以直接作用于for循环的数据类型有以下几种：
一类是集合数据类型，如list、tuple、dict、set、str等；
一类是generator，包括生成器和带yield的generator function。
这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。

可以使用isinstance()判断一个对象是否是Iterable对象：
生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。
Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。
可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

>>> from collections import Iterable
>>> isinstance([], Iterable)
True

生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。
把list、dict、str等Iterable变成Iterator可以使用iter()函数

Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，
直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，
但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，
所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。

Python的for循环本质上就是通过不断调用next()函数实现的

14. 函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，
通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。
函数就是面向过程的程序设计的基本单元。

对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；
越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。


函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，
因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。
而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。




15. 函数名是指向函数的变量。
既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

16. map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。

reduce()把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

filter()和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，
然后根据返回值是True还是False决定保留还是丢弃该元素。
注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。

sorted()函数就可以对list进行排序,sorted()函数也是一个高阶函数，可以接受一个key函数来实现自定义排序。
    key指定的函数将作用于list的每一个元素上，并根据key函数的返回结果进行排序。
    默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' < 'a'，结果，大写字母Z会排在小写字母a的前面。

16. lambda函数作为参数传递给其他函数：
部分Python内置函数接收函数作为参数。典型的此类内置函数有这些：

    filter函数。此时lambda函数用于指定过滤列表元素的条件。
    例如filter(lambda x: x % 3 == 0, [1, 2, 3])指定将列表[1,2,3]中能够被3整除的元素过滤出来，其结果是[3]。
    
    sorted函数。此时lambda函数用于指定对列表中所有元素进行排序的准则。
    例如sorted([1, 2, 3, 4, 5, 6, 7, 8, 9], key=lambda x: abs(5-x))将列表[1, 2, 3, 4, 5, 6, 7, 8, 9]按照元素与5距离从小到大进行排序，其结果是[5, 4, 6, 3, 7, 2, 8, 1, 9]。
    
    map函数。此时lambda函数用于指定对列表中每一个元素的共同操作。
    例如map(lambda x: x+1, [1, 2,3])将列表[1, 2, 3]中的元素分别加1，其结果[2, 3, 4]。
    
    reduce函数。此时lambda函数用于指定列表中两两相邻元素的结合条件。
    例如reduce(lambda a, b: '{}, {}'.format(a, b), [1, 2, 3, 4, 5, 6, 7, 8, 9])将列表?[1, 2, 3, 4, 5, 6, 7, 8, 9]中的元素从左往右两两以逗号分隔的字符的形式依次结合起来，其结果是'1, 2, 3, 4, 5, 6, 7, 8, 9'。

17. 在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，
当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。
当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数

 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

 
18. nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量
global关键字用来在函数或其他局部作用域中使用全局变量。
   但是如果不修改全局变量也可以不使用global关键字。如果局部要对全局变量修改，则在局部用global关键字声明该全局变量

19. 关键字lambda表示匿名函数，冒号前面的x表示函数参数。
匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

20. 假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，
    这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）
    本质上，decorator就是一个返回函数的高阶函数。
    
21. functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），
    返回一个新的函数，调用这个新函数会更简单。
    
22. 作用域
    __xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途
    _xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用
    private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，
    但是，从编程习惯上不应该引用private函数或变量。

23. 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。
    除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。
    
24. class 
    instance 
    objectt
    方法    __init__ 特殊的方法初始化数据
    
    类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；
    方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；
    通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。

    我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，
    都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。
    
25. 继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。
    动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。

26. python内置的@property装饰器负责把一个方法变成属性调用。
    这样既能检查参数，又可以用类似属性这样简单的方式来访问类的变量
	
	实例的变量名: __xxx，就变成了一个私有变量（private），只有内部可以访问，外部不能访问
	_xxx，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。
	变量名类似__xxx__的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。
		__len__()方法是为了能让class作用于len()函数
		__slots__变量，来限制该class实例能添加的属性
		__init__()方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。
		__str__()方法，返回一个好看的字符串
		__iter__()方法: 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象
		
10. python内置的@property装饰器负责把一个方法变成属性调用。
    这样既能检查参数，又可以用类似属性这样简单的方式来访问类的变量
	
	实例的变量名: __xxx，就变成了一个私有变量（private），只有内部可以访问，外部不能访问
	_xxx，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。
	变量名类似__xxx__的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。
		__len__()方法是为了能让class作用于len()函数
		__slots__变量，来限制该class实例能添加的属性
		__init__()方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。
		__str__()方法，返回一个好看的字符串
		__iter__()方法: 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象

11. python导入模块的方法有两种：import module 和 from module import，区别是前者所有导入的东西使用时需加上模块名的限定，而后者不需要。


13. functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。

14. splice
记住倒数第一个元素的索引是-1
L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
如果第一个索引是0，还可以省略： L[:3]